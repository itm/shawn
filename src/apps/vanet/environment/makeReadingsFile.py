#!/usr/bin/python
# -*- coding: utf-8 -*-

# makeReadingsFile generates events on a SUMO map and writes them in a file.
# Copyright (C) 2010, 2011  Walter Bamberger
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


"""The makeReadingsFile module provides methods to generate events on
a map and to write them in a configuration file for VANET readings.

An event describes a property of the world, like a traffic jam, a
price at a petrol station, the number of free spaces at a parking lot,
or the degree of rain. It is characterised by the following
attributes: 

* The location of the event (e.g. the coordinates of the petrol
  station or the parking lot); makeReadingsFile can only handle point
  locations, but not areas.

* The value of the event, like a price, the number of free parking
  space, or just a boolean value to say there is a traffic sign or
  not.

* The time when the value of the event becomes apparent (or
  valid). This is the start time.

* The time when the value of the event stops to be apparent (or valid).

* The type of the event, which describes the meaning of the event's
  value. For example, the type may refer to free parking space, to the
  price of a certain sort of petrol, or the existence of a traffic
  sign.

At present, makeReadingsFile handles the following four artificial
types: IntSituational, IntShort, IntMedium, IntLong. The idea is, not
to create a type for every event that can happen in reality but to
group the events according to their duration. For example, a traffic
jam last shorter than the validity of a petrol price; and a long
lasting event may be the existence of a certain traffic sign. This is
a simplification that remains valid for many simulation scenarios. 

The second simplification regards the value of an event. At present,
an event can have an integer value between 0 and 4. This might be
sufficient to evaluate algorithms that handle integer values.

Finally makeReadingsFile can only create events at a point
location. It cannot create an event that refers to an area like a
large traffic jam.

Events are generated according to an event configuration described in
the list eventConfigurations below. It contains the configuration of
every event type. The method placeEventsOnEdge then generate the
events of a certain type taking the configuration in this list. It is
called once for every event type.  The generated list of events is
then written to a file with the function writeEvents.  A simple
statistical evaluation of a list of events can be obtained on standard
output with the function printStatistics.

"""

import math
import argparse
import random
import sys
import xml.dom.minidom
import xml.sax

import sumonet


__author__ = "Walter Bamberger"
__version__ = "$Revision: 634 $"
# The range operator extracts the date from the whole Subversion string
__date__ = "$LastChangedDate: 2011-03-09 18:00:01 +0100 (Mi, 09 Mrz 2011) $"[18:28]

# The arguments generated by argparse. I consider them (like verbose or debug) 
# as global states in this program.
cliArgs = None

# This program can generate different types of events. They can be configured
# with the following parameters:
#   type:   The name of the event type as it is written to the readings file
#   number: The default number of events to generate of this type per year
#           (Can be overridden at the command line)
#   mu:     The duration of an event is computed with a normal distribution.
#           The is the mean of the distribution.
#   sigma:  This is the standard deviation of the normal distribution
eventConfigurations = [
    # Situational information
    {'type':'IntSituational', 'number':0, 'mu':5.0, 'sigma':3.0},
    
    # Short-term information for one trip: mu=1.5h, sigma=45min
    {'type':'IntShort', 'number':1000, 'mu':5400, 'sigma':2700},
    
    # Medium-term information for several trips: mu=4days, sigma=2day
    {'type':'IntMedium', 'number':100, 'mu':345600, 'sigma':172800},
    
    # Long-term information (persistent): mu=2years, sigma=1year
    {'type':'IntLong', 'number':10, 'mu':63072000, 'sigma':31536000}
    
    ]


class Event:
    """Data structure that collects the attributes of an event."""
    
    startTime = 0
    stopTime = 0
    position = (0.0, 0.0)
    type = ""
    value = 0


def pointsDistance(p1, p2):
    """Compute the Euklidean distance between two 2-dimensional vectors.

    The vectors p1 and p2 are sequences with two float elements (x, y). 
    It returns |p2  - p1|^2 as a float. 
    
    """
    
    diffX = p2[0] - p1[0]
    diffY = p2[1] - p1[1]
    return math.sqrt(diffX * diffX + diffY * diffY)


def lengthOfShape(shape):
    """Compute the length of a SUMO shape.
    
    The shape is a list of points. A point is a sequence of two floats. 
    The shape must contain at least one point coordinate. In this case, 
    the length is 0.0. The length of the shape is returned as a float.
    
    """
    
    prevPoint = shape[0]
    length = 0.0

    for point in shape:
        length = length + pointsDistance(prevPoint, point)
        prevPoint = point

    return length


def coordinatesOfPosition(shape, distance):
    """Compute the point at a given distance from the beginning of a shape.
    
    The shape is a list of points.  A point is a sequence of two floats.
    The returned point is the x- and y-coordinate of the point that has
    the given distance along the line of the shape from its starting point. 
    The shape must contain at least one point coordinate.  If the distance
    argument is larger than the length of the shape, the last point 
    of the shape is returned.
    
    """
    
    prevPoint = shape[0]
    currentDistance = 0.0

    for point in shape:
        diffX = point[0] - prevPoint[0]
        diffY = point[1] - prevPoint[1]
        sectionLength = math.sqrt(diffX * diffX + diffY * diffY)
        if currentDistance + sectionLength > distance:
            fraction = (distance - currentDistance) / sectionLength
            return (prevPoint[0] + diffX * fraction,
                    prevPoint[1] + diffY * fraction)
        currentDistance += sectionLength
    
    if cliArgs.debug:    
        print "coordinatesOfPosition: Exceeded the shape."
    return point


def placeEventOnEdge(eventConfiguration, edges):
    """Set up an event on an edge with a given configuration and return it.
    
    This method selects an edge out of the edges argument and a position 
    on that edge.  It places there an event with a duration and type as 
    given by the event configuration.  The event starts at a random startTime
    within the year.
    
    The event configuration is a map with at least the keys 'type', 'mu'
    and 'sigma'.  The 'type' key maps to a string with the type name, the
    'mu' and 'sigma' keys map to float values that describe the parameters
    of the normal distribution with which the duration (in seconds) of the
    event is computed.
    
    The argument edges is a list of type sumonet.NetEdge.  Out of this list,
    an edge is randomly chosen to place the event on it.  The position on
    the chosen edge is also random. 
    
    The starting startTime of an event is randomly set in a startTime frame 
    of one year plus the duration of the event.  This way, an event can start 
    before the beginning of the year (but end in the year) or end after the 
    end of the year (but start in the year).

    """    
    event = Event()

    edge = random.choice(edges)
    distanceFromBegin = random.uniform(0.0, lengthOfShape(edge.getShape()))
    event.position = coordinatesOfPosition(edge.getShape(), distanceFromBegin)
    
    duration = abs(int(random.normalvariate(
                eventConfiguration['mu'],
                eventConfiguration['sigma'])))
    event.startTime = random.randint(-duration, 365 * 24 * 3600)
    event.stopTime = event.startTime + duration

    event.type = eventConfiguration['type']
    event.value = random.randint(0, 4)  # value range 0 <= value <= 4

    return event


def writeEvents(events, fileName):
    """Write a list of events in a file.
    
    The argument events is a list of Event elements.  These elements are 
    put out in a file with the name fileName.
    
    The file is automatically created; a previous file with the same name 
    is overwritten!
    
    The format of the file is a custom XML format:
      <vanetreadings>
        <integerreading>
          <value startTime="123" stopTime="125", position="12.22,50.10" 
            type="INT_SHORT" value="3" />
          <value startTime="1244" stopTime="1264", position="15.22,20.10" 
            type="INT_MEDIUM" value="0" />
        </integerreading>
      </vanetreadings>

    """
    domImplementation = xml.dom.minidom.getDOMImplementation()
    doc = domImplementation.createDocument(None, 'vanetreadings', None)
    root = doc.documentElement
    readingElement = doc.createElement('integerreading')
    root.appendChild(readingElement)

    for event in events:
        readingValueElement = doc.createElement('value')        
        readingValueElement.setAttribute('startTime', str(event.startTime))
        readingValueElement.setAttribute('stopTime', str(event.stopTime))
        readingValueElement.setAttribute('position',
                                         '%.2f,%.2f' % event.position)
        readingValueElement.setAttribute('type', event.type)
        readingValueElement.setAttribute('value', str(event.value))
        readingElement.appendChild(readingValueElement)

    writer = open(fileName, 'w')
    doc.writexml(writer, '', '  ', newl='\n')


def printStatistics(events):
    """Print some characteristics of the generated events on standard output""" 
    
    durationOfOneYear = 3600 * 24 * 365
    # An event can start in the previous year but reach in the current one.
    # So two years must be considered for the start time.
    # Two years has 104 weeks plus 2 days (7 * 104 = 728 = 2 * 365 - 2).
    # So 105 weeks must be considered.
    eventsPerWeek = 112 * [0]
    eventsPerType = {}
    for eventConfiguration in eventConfigurations:
        eventsPerType[eventConfiguration['type']] = 0
        
    for event in events:
        week = event.startTime / 604800
        if week < -56:
            print 'Event with start time in week {0} found'.format(week)
            week = -56
        eventsPerWeek[week + 56] += 1
        eventsPerType[event.type] += 1
    
    print
    print 'Events per week:'
    eventCumulation = 0
    for z in range(28):
        print 'Week {0:3}:'.format(z * 4 - 56),
        for s in range(4):
            week = z * 4 + s - 56
            eventsThisWeek = eventsPerWeek[week + 56]
            eventCumulation += eventsThisWeek
            print '%6i' % eventsThisWeek,
        print '    âˆ‘ %6i' % eventCumulation 
    print 'Sum of all events: %i' % sum(eventsPerWeek)
    
    print
    print 'Events per type:'
    for (type, number) in eventsPerType.items():
        print '  %-15s: %4i' % (type, number)


def parseArguments():
    """Configures the command line arguments and provides their values. 

    The package argparse is used for that. The return value is the
    return value of parse_args.

    """
    argParser = argparse.ArgumentParser(description='Takes the map provided by the NET-FILE (SUMO net file format) and places events on it in form of reading values. These events are then written in the READINGS-FILE.')
    argParser.add_argument('NET_FILE',
                           help='The map in which the readings should be placed (input file in SUMO net file format)')
    argParser.add_argument('READINGS_FILE',
                           help='The readings configuration (output file)')
    argParser.add_argument('-v', '--verbose', action='store_true', default=False,
                         help='additional statistical output which may be interesting for the user')
    argParser.add_argument('--debug', action='store_true', default=False,
                         help='additional output for debugging the program')
    argParser.add_argument('--version', action='version', 
                           version='%(prog)s ' + __version__,
                           help='Print the version of %(prog)s')

    for eventConfiguration in eventConfigurations:
        argParser.add_argument('--N-' + eventConfiguration['type'], 
                               '--n-' + eventConfiguration['type'].lower(),
                               type=int,
                               default=eventConfiguration['number'],
                               help='The number of ' + eventConfiguration['type'] + ' events per year to be created')

    return argParser.parse_args()


def readSumoNetwork(netFile):
    """Reads in a SUMO network file and returns it.

    This method uses the sumonet package from the SUMO project. The
    return value is a Net class from this package.

    netFile -- the name of the SUMO network file

    """
    netReader = sumonet.NetReader()
    parser = xml.sax.make_parser()
    parser.setContentHandler(netReader)
    parser.parse(netFile)
    return netReader.getNet()


if __name__ == '__main__':
    cliArgs = parseArguments()
    net = readSumoNetwork(cliArgs.NET_FILE)
    
    # Generate the events
    events = []
    for eventConfiguration in eventConfigurations:
        for i in range(cliArgs.__dict__['N_' + eventConfiguration['type']]):
            event = placeEventOnEdge(eventConfiguration, net._edges)
            events.append(event)

    # Put out the events in a file
    writeEvents(events, cliArgs.READINGS_FILE)
    
    # Print some statistics to let the user verify everything worked right
    if cliArgs.verbose:
        printStatistics(events)
